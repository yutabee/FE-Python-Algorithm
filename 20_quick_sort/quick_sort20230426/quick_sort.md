- [クイックソート](#クイックソート)
  - [クイックソートのアルゴリズム手順](#クイックソートのアルゴリズム手順)
  - [クイックソートの特徴](#クイックソートの特徴)
  - [インプレースソートとして実装したクイックソート](#インプレースソートとして実装したクイックソート)

# クイックソート

クイックソートは、分割統治法（Divide and Conquer）を利用した高速なソートアルゴリズムです。平均計算時間が O(n log n)であり、最悪の場合でも O(n^2)ですが、実際には非常に高速に動作します。また、**インプレースソート**であり、追加のメモリ領域をほとんど使用しないため、実用的なアルゴリズムとして広く利用されています。

## クイックソートのアルゴリズム手順

1. リスト内から 1 つの要素を選びます。この要素をピボット（軸）と呼びます。ピボットの選び方は様々ですが、リストの先頭、中央、末尾の要素の中央値を選ぶ方法やランダムに選ぶ方法が一般的です。

2. ピボットを基準に、ピボットより小さい要素を左側に、ピボットより大きい要素を右側に配置します。これを**パーティション**（分割）と呼びます。パーティション操作を行うことで、ピボットの位置はソート済みとなります。

3. ピボットを除いた左側の部分リストと右側の部分リストに対して、再帰的に手順 1 と 2 を適用していきます。

4. 部分リストの要素数が 1 以下になったら、ソートは完了です。

## クイックソートの特徴

- 適切なピボット選択とパーティションの実装方法によって、高速に動作することが特徴です。
- 最悪の場合（すでにソートされたリストや逆順にソートされたリストなど）では、O(n^2)の計算時間がかかる可能性があるため、適用するデータに注意が必要です。
- 安定性がないため、同じ値の要素の順序が保証されません。
- 追加のメモリ領域をほとんど使用しないため、インプレースソートとして利用されます。

以上がクイックソートに関する基本的な説明です。理解しやすいように、具体的なコード例も用意しましょう。Python でクイックソートを実装した例を以下に示します。

```python
def quick_sort(arr: list) -> list:
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)
```

上記のコードは、Python でクイックソートを実装したものです。引数`arr`に対して、以下の手順でソートを行っています。

1. 配列`arr`の要素数が 1 以下の場合、ソート済みとしてそのまま返します。

2. ピボットを配列の中央値として選びます。

3. ピボットより小さい要素を`left`、ピボットと等しい要素を`middle`、ピボットより大きい要素を`right`に格納します。

4. `left`と`right`に対して再帰的にクイックソートを実行し、`left`、`middle`、`right`を結合してソート済みの配列を返します。

このように、クイックソートは再帰的なアルゴリズムを用いて、高速に配列をソートすることができます。ただし、実際の実装ではインプレースソートとして実装することが一般的であり、上記の例は理解しやすい形で記述されていますが、メモリ効率は良くありません。インプレースソートを実現するためには、パーティション操作を行う際に、要素の交換を直接配列内で行うように実装を工夫する必要があります。

## インプレースソートとして実装したクイックソート

メモリ効率を考慮したクイックソートの実装例を以下に示します。この例では、インプレースソートが実現されています。

```python
def quick_sort(arr: list, low: int, high: int) -> None:
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort(arr, low, pivot_index)
        quick_sort(arr, pivot_index + 1, high)

def partition(arr: list, low: int, high: int) -> int:
    pivot = arr[low]
    left = low + 1
    right = high

    done = False
    while not done:
        while left <= right and arr[left] <= pivot:
            left = left + 1
        while arr[right] >= pivot and right >= left:
            right = right - 1

        if right < left:
            done = True
        else:
            arr[left], arr[right] = arr[right], arr[left]

    arr[low], arr[right] = arr[right], arr[low]
    return right

arr = [3, 6, 8, 10, 1, 2, 1]
quick_sort(arr, 0, len(arr) - 1)
print(arr)
```

この実装では、`quick_sort`関数と`partition`関数を定義しています。

- `quick_sort`関数は、引数として配列`arr`、範囲の最小インデックス`low`、範囲の最大インデックス`high`を受け取り、範囲内の要素をソートします。最初に呼び出す際は、`low`に`0`、`high`に`len(arr) - 1`を指定します。
- `partition`関数は、引数として配列`arr`、範囲の最小インデックス`low`、範囲の最大インデックス`high`を受け取り、ピボットの位置を返します。また、パーティション操作を行い、配列の要素を直接交換することで、インプレースソートを実現しています。

このように、配列内で要素の交換を行うことで、メモリ効率を向上させたクイックソートを実装することができます。
